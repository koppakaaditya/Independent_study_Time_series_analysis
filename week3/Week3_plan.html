<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>week3_plan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Week3_plan_files/libs/clipboard/clipboard.min.js"></script>
<script src="Week3_plan_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Week3_plan_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Week3_plan_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="Week3_plan_files/libs/quarto-html/popper.min.js"></script>
<script src="Week3_plan_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Week3_plan_files/libs/quarto-html/anchor.min.js"></script>
<link href="Week3_plan_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Week3_plan_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Week3_plan_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Week3_plan_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Week3_plan_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>title: ‚ÄúWeek 3: Long Short-Term Memory Networks (LSTMs) Deep Dive (PyTorch)‚Äù subtitle: ‚ÄúConquering Long-Term Dependencies with Gated Memory‚Äù format: html</p>
<p>üìÖ Focus: Gates, Cells, and Sequence Modeling Mastery</p>
<p>The Long Short-Term Memory (LSTM) is the workhorse of classical deep learning for time series and is paramount for modeling stock data. Its internal gated mechanisms allow it to explicitly control which information to keep and which to discard, solving the vanishing gradient problem that plagues simple RNNs.</p>
<p>üß† Deep Learning Architecture: The LSTM Cell</p>
<p>The magic of the LSTM lies in its three gates and its cell state (<span class="math inline">\(C_t\)</span>):</p>
<p>Forget Gate (<span class="math inline">\(f_t\)</span>): Decides what information from the previous cell state <span class="math inline">\(C_{t-1}\)</span> to throw away.</p>
<p>Input Gate (<span class="math inline">\(i_t\)</span>): Decides what new information from the current input <span class="math inline">\(x_t\)</span> to store in the cell state.</p>
<p>Output Gate (<span class="math inline">\(o_t\)</span>): Decides what parts of the cell state <span class="math inline">\(C_t\)</span> should be outputted as the hidden state <span class="math inline">\(h_t\)</span>.</p>
<p>The ability to maintain the cell state across long sequences is what makes LSTMs superior for capturing long-term financial trends and relationships.</p>
<p>üìä Signal Analysis: Autocorrelation and Lookback</p>
<p>The ideal size of your lookback window (<span class="math inline">\(T\)</span>) should be informed by the Partial Autocorrelation Function (PACF). While ACF tells you total dependence, PACF shows the direct dependence between <span class="math inline">\(P_t\)</span> and <span class="math inline">\(P_{t-k}\)</span> after controlling for the values in between (<span class="math inline">\(P_{t-1}\)</span> to <span class="math inline">\(P_{t-k+1}\)</span>).</p>
<p>üìö Libraries</p>
<p>torch (PyTorch LSTM implementation)</p>
<p>scikit-learn (Standardization)</p>
<p>pandas, numpy</p>
<p>Starter Code: Implementing a Stacked PyTorch LSTM for Forecasting</p>
<p>This code demonstrates how to define a stacked LSTM model in PyTorch, which is often more powerful for learning hierarchical temporal features.</p>
<p>import numpy as np import pandas as pd import torch import torch.nn as nn from torch.utils.data import Dataset, DataLoader from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split</p>
<section id="prepare-data" class="level1">
<h1>‚Äî 1. Prepare Data ‚Äî</h1>
<p>def generate_time_series(data_size: int = 500) -&gt; pd.DataFrame: ‚Äú‚Äú‚Äù Generates a synthetic time series (noisy sine wave with trend).</p>
<pre><code>Args:
    data_size: The number of time steps.

Returns:
    pd.DataFrame: DataFrame with the time series 'Value'.
"""
time = np.arange(0, data_size)
amplitude = 5
frequency = 0.05
trend = 0.01 * time
noise = np.random.randn(len(time)) * 0.5
series = amplitude * np.sin(2 * np.pi * frequency * time) + trend + noise
return pd.DataFrame({'Value': series})</code></pre>
<p>class UnivariateTimeSeriesDataset(Dataset): ‚Äú‚Äú‚Äù A PyTorch Dataset for creating time series sequences from a single feature. ‚Äú‚Äú‚Äù def <strong>init</strong>(self, data_array: np.ndarray, lookback: int): ‚Äú‚Äú‚Äù Initializes the dataset.</p>
<pre><code>    Args:
        data_array: 1D NumPy array of the time series feature.
        lookback: The length of the input sequence (Time Steps).
    """
    # Convert NumPy to PyTorch tensor, and add a feature dimension
    self.data_tensor = torch.tensor(data_array, dtype=torch.float32).unsqueeze(-1).contiguous()
    self.lookback = lookback
    self.num_samples = len(data_array) - lookback

def __len__(self) -&gt; int:
    """
    Returns the total number of sequences/samples.
    """
    return self.num_samples

def __getitem__(self, idx: int) -&gt; tuple[torch.Tensor, torch.Tensor]:
    """
    Retrieves one input sequence (X) and its corresponding target (y).

    Args:
        idx: Index of the sample to retrieve.

    Returns:
        tuple[torch.Tensor, torch.Tensor]: 
            The input sequence (X) and the target value (y).
    """
    x = self.data_tensor[idx:idx + self.lookback]
    y = self.data_tensor[idx + self.lookback]
    return x, y</code></pre>
</section>
<section id="execution" class="level1">
<h1>‚Äî Execution ‚Äî</h1>
<p>df = generate_time_series()</p>
</section>
<section id="normalize-the-single-feature-value" class="level1">
<h1>Normalize the single feature (Value)</h1>
<p>scaler = StandardScaler() scaled_series = scaler.fit_transform(df[[‚ÄòValue‚Äô]].values)</p>
<p>LOOKBACK = 20 N_FEATURES = 1</p>
</section>
<section id="traintest-split-chronological-split-is-used-for-time-series" class="level1">
<h1>Train/Test Split (Chronological Split is used for time series)</h1>
<p>train_size = int(len(scaled_series) * 0.8) train_data = scaled_series[:train_size] # Ensure test data includes the lookback period from the end of the training data test_data = scaled_series[train_size - LOOKBACK:]</p>
</section>
<section id="create-dataloaders" class="level1">
<h1>Create DataLoaders</h1>
<p>train_dataset = UnivariateTimeSeriesDataset(train_data, LOOKBACK) train_loader = DataLoader(train_dataset, batch_size=64, shuffle=False) X_example, _ = next(iter(train_loader))</p>
</section>
<section id="define-the-stacked-pytorch-lstm-model" class="level1">
<h1>‚Äî 2. Define the Stacked PyTorch LSTM Model ‚Äî</h1>
<p>class StackedLSTMModel(nn.Module): ‚Äú‚Äú‚Äù A Stacked LSTM model for time series forecasting. ‚Äú‚Äú‚Äù def <strong>init</strong>(self, input_size: int, hidden_size: int, output_size: int, num_layers: int): ‚Äú‚Äú‚Äù Initializes the StackedLSTMModel.</p>
<pre><code>    Args:
        input_size: The number of expected features in the input (N_features).
        hidden_size: The number of features in the hidden state h.
        output_size: The number of output features (e.g., 1).
        num_layers: The number of LSTM layers to stack.
    """
    super().__init__()
    self.hidden_size = hidden_size
    self.num_layers = num_layers
    
    # nn.LSTM handles stacking internally via num_layers
    self.lstm = nn.LSTM(
        input_size, 
        hidden_size, 
        num_layers, 
        batch_first=True
    )
    self.fc = nn.Linear(hidden_size, output_size)

def forward(self, x: torch.Tensor) -&gt; torch.Tensor:
    """
    Forward pass of the model.

    Args:
        x: Input tensor of shape (batch_size, sequence_length, input_size).

    Returns:
        torch.Tensor: Predicted output tensor of shape (batch_size, output_size).
    """
    # lstm_out: (batch_size, seq_len, hidden_size)
    # (hn, cn): (num_layers, batch_size, hidden_size)
    lstm_out, (hn, cn) = self.lstm(x)
    
    # We only take the hidden state of the LAST time step in the sequence
    # lstm_out[:, -1, :] is the output of the last LSTM layer at the last time step
    output = self.fc(lstm_out[:, -1, :])
    return output</code></pre>
</section>
<section id="model-instantiation-and-summary" class="level1">
<h1>‚Äî 3. Model Instantiation and Summary ‚Äî</h1>
<p>HIDDEN_SIZE = 64 OUTPUT_SIZE = 1 NUM_LAYERS = 2 # Stacked LSTM</p>
<p>model = StackedLSTMModel( input_size=N_FEATURES, hidden_size=HIDDEN_SIZE, output_size=OUTPUT_SIZE, num_layers=NUM_LAYERS )</p>
</section>
<section id="print-a-conceptual-summary" class="level1">
<h1>Print a conceptual summary</h1>
<p>print(f‚ÄùX batch shape: {X_example.shape}‚Äú) print(f‚ÄùNumber of Features: {N_FEATURES}‚Äú) print(f‚ÄùNumber of LSTM layers: {NUM_LAYERS}‚Äú) print(‚Äù‚Äî Stacked PyTorch LSTM Model Summary ‚Äî‚Äú) print(model)</p>
</section>
<section id="conceptual-training-setup" class="level1">
<h1>Conceptual training setup:</h1>
</section>
<section id="optimizer-torch.optim.adammodel.parameters-lr0.001" class="level1">
<h1>optimizer = torch.optim.Adam(model.parameters(), lr=0.001)</h1>
</section>
<section id="loss_fn-nn.mseloss" class="level1">
<h1>loss_fn = nn.MSELoss()</h1>
</section>
<section id="model.train" class="level1">
<h1>model.train()</h1>
</section>
<section id="for-x_batch-y_batch-in-train_loader" class="level1">
<h1>for X_batch, y_batch in train_loader:</h1>
</section>
<section id="training-loop-steps" class="level1">
<h1># Training loop steps‚Ä¶</h1>
</section>
<section id="pass" class="level1">
<h1>pass</h1>
<p>‚è≠ Next Steps for Week 4</p>
<p>Next week, we move away from purely recurrent architectures and introduce Convolutional Neural Networks (CNNs) to act as local pattern extractors in the time dimension using a Hybrid CNN-LSTM approach.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>